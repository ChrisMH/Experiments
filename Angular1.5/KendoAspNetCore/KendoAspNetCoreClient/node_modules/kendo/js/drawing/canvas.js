module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(479);
	module.exports = __webpack_require__(479);


/***/ },

/***/ 3:
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },

/***/ 479:
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(480), __webpack_require__(481) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function(){

	(function ($) {

	    // Imports ================================================================
	    var doc = document,

	        kendo = window.kendo,
	        deepExtend = kendo.deepExtend,

	        util = kendo.util,
	        defined = util.defined,
	        isTransparent = util.isTransparent,
	        renderTemplate = util.renderTemplate,
	        valueOrDefault = util.valueOrDefault,

	        g = kendo.geometry,
	        d = kendo.drawing,
	        BaseNode = d.BaseNode,

	        proxy = $.proxy;

	    // Constants ==============================================================
	    var BUTT = "butt",
	        DASH_ARRAYS = d.DASH_ARRAYS,
	        FRAME_DELAY = 1000 / 60,
	        SOLID = "solid",
	        NS = ".kendo";

	    // Canvas Surface ==========================================================
	    var Surface = d.Surface.extend({
	        init: function(element, options) {
	            d.Surface.fn.init.call(this, element, options);

	            this.element[0].innerHTML = this._template(this);
	            var canvas = this.element[0].firstElementChild;
	            canvas.width = $(element).width();
	            canvas.height = $(element).height();
	            this._rootElement = canvas;

	            this._root = new RootNode(canvas);
	        },

	        destroy: function() {
	            d.Surface.fn.destroy.call(this);

	            if (this._root) {
	                this._root.destroy();
	                this._root = null;
	            }

	            if (this._searchTree) {
	                this._searchTree.clear();
	                delete this._searchTree;
	            }

	            this.element.off(NS);
	        },

	        type: "canvas",

	        draw: function(element) {
	            d.Surface.fn.draw.call(this, element);
	            this._root.load([element], undefined, this.options.cors);

	            if (this._searchTree) {
	                this._searchTree.add([element]);
	            }
	        },

	        clear: function() {
	            d.Surface.fn.clear.call(this);
	            this._root.clear();

	            if (this._searchTree) {
	                this._searchTree.clear();
	            }
	        },

	        eventTarget: function(e) {
	            if (this._searchTree) {
	                var point = this._surfacePoint(e);
	                var shape = this._searchTree.pointShape(point);
	                return shape;
	            }
	        },

	        image: function() {
	            var root = this._root;
	            var rootElement = this._rootElement;

	            var loadingStates = [];
	            root.traverse(function(childNode) {
	                if (childNode.loading) {
	                    loadingStates.push(childNode.loading);
	                }
	            });

	            var defer = $.Deferred();
	            $.when.apply($, loadingStates).done(function() {
	                root._invalidate();

	                try {
	                    var data = rootElement.toDataURL();
	                    defer.resolve(data);
	                } catch (e) {
	                    defer.reject(e);
	                }
	            }).fail(function(e) {
	                defer.reject(e);
	            });

	            return defer.promise();
	        },

	        suspendTracking: function() {
	            d.Surface.fn.suspendTracking.call(this);
	            if (this._searchTree) {
	                this._searchTree.clear();
	                delete this._searchTree;
	            }
	        },

	        resumeTracking: function() {
	            d.Surface.fn.resumeTracking.call(this);
	            if (!this._searchTree) {
	                this._searchTree = new d.ShapesQuadTree();

	                var childNodes = this._root.childNodes;
	                var rootElements = [];
	                for (var idx = 0; idx < childNodes.length; idx++) {
	                    rootElements.push(childNodes[idx].srcElement);
	                }
	                this._searchTree.add(rootElements);
	            }
	        },

	        _resize: function() {
	            this._rootElement.width = this._size.width;
	            this._rootElement.height = this._size.height;

	            this._root.invalidate();
	        },

	        _template: renderTemplate(
	            "<canvas style='width: 100%; height: 100%;'></canvas>"
	        ),

	        _enableTracking: function() {
	            this._searchTree = new d.ShapesQuadTree();
	            this._mouseTrackHandler = proxy(this._trackMouse, this);

	            this.element.on("click" + NS, this._mouseTrackHandler);
	            this.element.on("mousemove" + NS, this._mouseTrackHandler);

	            d.Surface.fn._enableTracking.call(this);
	        },

	        _trackMouse: function(e) {
	            if (this._suspendedTracking){
	                return;
	            }
	            var shape = this.eventTarget(e);

	            if (e.type != "click") {
	                var currentShape = this._currentShape;
	                if (currentShape && currentShape !== shape) {
	                    this.trigger("mouseleave", {
	                        element: currentShape,
	                        originalEvent: e,
	                        type: "mouseleave"
	                    });
	                }

	                if (shape && currentShape !== shape) {
	                   this.trigger("mouseenter", {
	                       element: shape,
	                       originalEvent: e,
	                       type: "mouseenter"
	                   });
	                }

	                this.trigger("mousemove", {
	                   element: shape,
	                   originalEvent: e,
	                   type: "mousemove"
	                });

	                this._currentShape = shape;
	            } else if (shape) {
	                this.trigger("click", {
	                   element: shape,
	                   originalEvent: e,
	                   type: "click"
	                });
	            }
	        }
	    });

	    // Nodes ===================================================================
	    var Node = BaseNode.extend({
	        init: function(srcElement) {
	            BaseNode.fn.init.call(this, srcElement);
	            if (srcElement) {
	                this.initClip();
	            }
	        },

	        initClip: function() {
	            var clip = this.srcElement.clip();
	            if (clip) {
	                this.clip = clip;
	                clip.addObserver(this);
	            }
	        },

	        clear: function() {
	            if (this.srcElement) {
	                this.srcElement.removeObserver(this);
	            }

	            this.clearClip();

	            BaseNode.fn.clear.call(this);
	        },

	        clearClip: function() {
	            if (this.clip) {
	                this.clip.removeObserver(this);
	                delete this.clip;
	            }
	        },

	        setClip: function(ctx) {
	            if (this.clip) {
	                ctx.beginPath();
	                PathNode.fn.renderPoints(ctx, this.clip);
	                ctx.clip();
	            }
	        },

	        optionsChange: function(e) {
	            if (e.field == "clip") {
	                this.clearClip();
	                this.initClip();
	            }

	            BaseNode.fn.optionsChange.call(this, e);
	        },

	        setTransform: function(ctx) {
	            if (this.srcElement) {
	                var transform = this.srcElement.transform();
	                if (transform) {
	                    ctx.transform.apply(ctx, transform.matrix().toArray(6));
	                }
	            }
	        },

	        loadElements: function(elements, pos, cors) {
	            var node = this,
	                childNode,
	                srcElement,
	                children,
	                i;

	            for (i = 0; i < elements.length; i++) {
	                srcElement = elements[i];
	                children = srcElement.children;

	                childNode = new nodeMap[srcElement.nodeType](srcElement, cors);

	                if (children && children.length > 0) {
	                    childNode.load(children, pos, cors);
	                }

	                if (defined(pos)) {
	                    node.insertAt(childNode, pos);
	                } else {
	                    node.append(childNode);
	                }
	            }
	        },

	        load: function(elements, pos, cors) {
	            this.loadElements(elements, pos, cors);

	            this.invalidate();
	        },

	        setOpacity: function(ctx) {
	            if (this.srcElement) {
	                var opacity = this.srcElement.opacity();
	                if (defined(opacity)) {
	                    this.globalAlpha(ctx, opacity);
	                }
	            }
	        },

	        globalAlpha: function(ctx, value) {
	            if (value && ctx.globalAlpha) {
	                value *= ctx.globalAlpha;
	            }
	            ctx.globalAlpha = value;
	        },

	        visible: function() {
	            var src = this.srcElement;
	            return !src || (src && src.options.visible !== false);
	        }
	    });

	    var GroupNode = Node.extend({
	        renderTo: function(ctx) {
	            if (!this.visible()) {
	                return;
	            }

	            ctx.save();

	            this.setTransform(ctx);
	            this.setClip(ctx);
	            this.setOpacity(ctx);

	            var childNodes = this.childNodes;
	            for (var i = 0; i < childNodes.length; i++) {
	                var child = childNodes[i];
	                if (child.visible()) {
	                    child.renderTo(ctx);
	                }
	            }

	            ctx.restore();
	        }
	    });
	    d.mixins.Traversable.extend(GroupNode.fn, "childNodes");

	    var RootNode = GroupNode.extend({
	        init: function(canvas) {
	            GroupNode.fn.init.call(this);

	            this.canvas = canvas;
	            this.ctx = canvas.getContext("2d");

	            var invalidateHandler = proxy(this._invalidate, this);
	            this.invalidate = kendo.throttle(function() {
	                    kendo.animationFrame(invalidateHandler);
	                },
	                FRAME_DELAY
	            );
	        },

	        destroy: function() {
	            GroupNode.fn.destroy.call(this);
	            this.canvas = null;
	            this.ctx = null;
	        },

	        load: function(elements, pos, cors) {
	            this.loadElements(elements, pos, cors);
	            this._invalidate();
	        },

	        _invalidate: function() {
	            if (!this.ctx) {
	                return;
	            }
	            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
	            this.renderTo(this.ctx);
	        }
	    });
	    d.mixins.Traversable.extend(RootNode.fn, "childNodes");

	    var PathNode = Node.extend({
	        renderTo: function(ctx) {
	            ctx.save();

	            this.setTransform(ctx);
	            this.setClip(ctx);
	            this.setOpacity(ctx);

	            ctx.beginPath();

	            this.renderPoints(ctx, this.srcElement);

	            this.setLineDash(ctx);
	            this.setLineCap(ctx);
	            this.setLineJoin(ctx);

	            this.setFill(ctx);
	            this.setStroke(ctx);

	            ctx.restore();
	        },

	        setFill: function(ctx) {
	            var fill = this.srcElement.options.fill;
	            var hasFill = false;

	            if (fill) {
	                if (fill.nodeType == "gradient") {
	                    this.setGradientFill(ctx, fill);
	                    hasFill = true;
	                } else if (!isTransparent(fill.color)) {
	                    ctx.fillStyle = fill.color;

	                    ctx.save();
	                    this.globalAlpha(ctx, fill.opacity);
	                    ctx.fill();
	                    ctx.restore();

	                    hasFill = true;
	                }
	            }

	            return hasFill;
	        },

	        setGradientFill: function(ctx, fill) {
	            var bbox = this.srcElement.rawBBox();
	            var gradient;

	            if (fill instanceof d.LinearGradient) {
	                var start = fill.start();
	                var end = fill.end();
	                gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
	            } else if (fill instanceof d.RadialGradient) {
	                var center = fill.center();
	                gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());
	            }

	            addGradientStops(gradient, fill.stops);

	            ctx.save();

	            if (!fill.userSpace()) {
	                ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);
	            }
	            ctx.fillStyle = gradient;
	            ctx.fill();

	            ctx.restore();
	        },

	        setStroke: function(ctx) {
	            var stroke = this.srcElement.options.stroke;
	            if (stroke && !isTransparent(stroke.color) && stroke.width > 0) {
	                ctx.strokeStyle = stroke.color;
	                ctx.lineWidth = valueOrDefault(stroke.width, 1);

	                ctx.save();
	                this.globalAlpha(ctx, stroke.opacity);
	                ctx.stroke();
	                ctx.restore();

	                return true;
	            }
	        },

	        dashType: function() {
	            var stroke = this.srcElement.options.stroke;
	            if (stroke && stroke.dashType) {
	                return stroke.dashType.toLowerCase();
	            }
	        },

	        setLineDash: function(ctx) {
	            var dashType = this.dashType();
	            if (dashType && dashType != SOLID) {
	                var dashArray = DASH_ARRAYS[dashType];
	                if (ctx.setLineDash) {
	                    ctx.setLineDash(dashArray);
	                } else {
	                    ctx.mozDash = dashArray;
	                    ctx.webkitLineDash = dashArray;
	                }
	            }
	        },

	        setLineCap: function(ctx) {
	            var dashType = this.dashType();
	            var stroke = this.srcElement.options.stroke;
	            if (dashType && dashType !== SOLID) {
	                ctx.lineCap = BUTT;
	            } else if (stroke && stroke.lineCap) {
	                ctx.lineCap = stroke.lineCap;
	            }
	        },

	        setLineJoin: function(ctx) {
	            var stroke = this.srcElement.options.stroke;
	            if (stroke && stroke.lineJoin) {
	                ctx.lineJoin = stroke.lineJoin;
	            }
	        },

	        renderPoints: function(ctx, path) {
	            var segments = path.segments;

	            if (segments.length === 0) {
	                return;
	            }

	            var seg = segments[0];
	            var anchor = seg.anchor();
	            ctx.moveTo(anchor.x, anchor.y);

	            for (var i = 1; i < segments.length; i++) {
	                seg = segments[i];
	                anchor = seg.anchor();

	                var prevSeg = segments[i - 1];
	                var prevOut = prevSeg.controlOut();
	                var controlIn = seg.controlIn();

	                if (prevOut && controlIn) {
	                    ctx.bezierCurveTo(prevOut.x, prevOut.y,
	                                      controlIn.x, controlIn.y,
	                                      anchor.x, anchor.y);
	                } else {
	                    ctx.lineTo(anchor.x, anchor.y);
	                }
	            }

	            if (path.options.closed) {
	                ctx.closePath();
	            }
	        }
	    });

	    var MultiPathNode = PathNode.extend({
	        renderPoints: function(ctx) {
	            var paths = this.srcElement.paths;
	            for (var i = 0; i < paths.length; i++) {
	                PathNode.fn.renderPoints(ctx, paths[i]);
	            }
	        }
	    });

	    var CircleNode = PathNode.extend({
	        renderPoints: function(ctx) {
	            var geometry = this.srcElement.geometry();
	            var c = geometry.center;
	            var r = geometry.radius;

	            ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
	        }
	    });

	    var ArcNode = PathNode.extend({
	        renderPoints: function(ctx) {
	            var path = this.srcElement.toPath();
	            PathNode.fn.renderPoints.call(this, ctx, path);
	        }
	    });

	    var TextNode = PathNode.extend({
	        renderTo: function(ctx) {
	            var text = this.srcElement;
	            var pos = text.position();
	            var size = text.measure();

	            ctx.save();

	            this.setTransform(ctx);
	            this.setClip(ctx);
	            this.setOpacity(ctx);

	            ctx.beginPath();

	            ctx.font = text.options.font;
	            if (this.setFill(ctx)) {
	                ctx.fillText(text.content(), pos.x, pos.y + size.baseline);
	            }

	            if (this.setStroke(ctx)) {
	                this.setLineDash(ctx);
	                ctx.strokeText(text.content(), pos.x, pos.y + size.baseline);
	            }

	            ctx.restore();
	        }
	    });

	    var ImageNode = PathNode.extend({
	        init: function(srcElement, cors) {
	            PathNode.fn.init.call(this, srcElement);

	            this.onLoad = proxy(this.onLoad, this);
	            this.onError = proxy(this.onError, this);
	            this.loading = $.Deferred();

	            var img = this.img = new Image();

	            if (cors && !(/^data:/i.test(srcElement.src()))) {
	                img.crossOrigin = cors;
	            }

	            img.src = srcElement.src();

	            if (img.complete) {
	                this.onLoad();
	            } else {
	                img.onload = this.onLoad;
	                img.onerror = this.onError;
	            }
	        },

	        renderTo: function(ctx) {
	            if (this.loading.state() === "resolved") {
	                ctx.save();

	                this.setTransform(ctx);
	                this.setClip(ctx);

	                this.drawImage(ctx);

	                ctx.restore();
	            }
	        },

	        optionsChange: function(e) {
	            if (e.field === "src") {
	                this.loading = $.Deferred();
	                this.img.src = this.srcElement.src();
	            } else {
	                PathNode.fn.optionsChange.call(this, e);
	            }
	        },

	        onLoad: function() {
	            this.loading.resolve();
	            this.invalidate();
	        },

	        onError: function() {
	            this.loading.reject(new Error(
	                "Unable to load image '" + this.img.src +
	                "'. Check for connectivity and verify CORS headers."
	            ));
	        },

	        drawImage: function(ctx) {
	            var rect = this.srcElement.rect();
	            var tl = rect.topLeft();

	            ctx.drawImage(
	                this.img, tl.x, tl.y, rect.width(), rect.height()
	            );
	        }
	    });

	    var RectNode = PathNode.extend({
	        renderPoints: function(ctx) {
	            var geometry = this.srcElement.geometry();
	            var origin = geometry.origin;
	            var size = geometry.size;

	            ctx.rect(origin.x, origin.y, size.width, size.height);
	        }
	    });

	    function exportImage(group, options) {
	        var defaults = {
	            width: "800px", height: "600px",
	            cors: "Anonymous"
	        };

	        var bbox = group.clippedBBox();
	        if (bbox) {
	            var origin = bbox.getOrigin();
	            var exportRoot = new d.Group();
	            exportRoot.transform(g.transform().translate(-origin.x, -origin.y));
	            exportRoot.children.push(group);
	            group = exportRoot;

	            var size = bbox.getSize();
	            defaults.width = size.width + "px";
	            defaults.height = size.height + "px";
	        }

	        options = deepExtend(defaults, options);

	        var container = $("<div />").css({
	            display: "none",
	            width: options.width,
	            height: options.height
	        }).appendTo(document.body);

	        var surface = new Surface(container, options);
	        surface.suspendTracking();
	        surface.draw(group);

	        var promise = surface.image();
	        promise.always(function() {
	            surface.destroy();
	            container.remove();
	        });

	        return promise;
	    }

	    var nodeMap = {
	        Group: GroupNode,
	        Text: TextNode,
	        Path: PathNode,
	        MultiPath: MultiPathNode,
	        Circle: CircleNode,
	        Arc: ArcNode,
	        Image: ImageNode,
	        Rect: RectNode
	    };

	    // Helpers ================================================================
	    function addGradientStops(gradient, stops) {
	        var color, stop, idx;

	        for (idx = 0; idx < stops.length; idx++) {
	            stop = stops[idx];
	            color = kendo.parseColor(stop.color());
	            color.a *= stop.opacity();
	            gradient.addColorStop(stop.offset(), color.toCssRgba());
	        }
	    }

	    // Exports ================================================================
	    kendo.support.canvas = (function() {
	        return !!doc.createElement("canvas").getContext;
	    })();

	    if (kendo.support.canvas) {
	        d.SurfaceFactory.current.register("canvas", Surface, 20);
	    }

	    deepExtend(kendo.drawing, {
	        exportImage: exportImage,

	        canvas: {
	            ArcNode: ArcNode,
	            CircleNode: CircleNode,
	            GroupNode: GroupNode,
	            ImageNode: ImageNode,
	            MultiPathNode: MultiPathNode,
	            Node: Node,
	            PathNode: PathNode,
	            RectNode: RectNode,
	            RootNode: RootNode,
	            Surface: Surface,
	            TextNode: TextNode
	        }
	    });

	})(window.kendo.jQuery);

	}, __webpack_require__(3));


/***/ },

/***/ 480:
/***/ function(module, exports) {

	module.exports = require("./search");

/***/ },

/***/ 481:
/***/ function(module, exports) {

	module.exports = require("../kendo.color");

/***/ }

/******/ });